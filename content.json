{"meta":{"title":"Kevin's Blog","subtitle":"","description":"请多指教","author":"DaftPumpkin","url":"https://daftpumpkin.github.io","root":"/"},"pages":[],"posts":[{"title":"C++学习笔记","slug":"C-学习笔记","date":"2021-04-29T13:36:50.607Z","updated":"2021-04-29T14:08:56.790Z","comments":true,"path":"2021/04/29/C-学习笔记/","link":"","permalink":"https://daftpumpkin.github.io/2021/04/29/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"C++学习笔记 [TOC] 一、类与对象1.类的定义1234567class Clock &#123; public: void setTime(int newH, int newM, int newS); void showTime(); //在类中可以只声明函数的原型，函数的实现（函数体）可以在类外定义 private: int hour, minute, second;&#125;; 将抽象出的数据和行为相结合，将它们视为一个整体将数据与操作数据的函数进行有机结合，形成“类”其中的数据和函数都是类的成员数据成员函数成员 2.类成员的访问控制公有类型成员在关键字public后面声明，它们是类与外部的接口，任何外部函数都可以访问公有类型数据和函数 私有类型成员在关键字private后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问如果紧跟在类名称的后面声明私有成员，则关键字private可以省略数据成员尽量声明为私有成员 保护类型成员与private类似，其差别表现在继承与派生时对派生类的影响不同 3.对象类的对象是该类的某一特定实体声明形式： 类名 对象名；例：Clock myClock;类中成员互访直接使用成员名类外访问使用“对象名.成员名”方式访问 public 属性的成员","text":"C++学习笔记 [TOC] 一、类与对象1.类的定义1234567class Clock &#123; public: void setTime(int newH, int newM, int newS); void showTime(); //在类中可以只声明函数的原型，函数的实现（函数体）可以在类外定义 private: int hour, minute, second;&#125;; 将抽象出的数据和行为相结合，将它们视为一个整体将数据与操作数据的函数进行有机结合，形成“类”其中的数据和函数都是类的成员数据成员函数成员 2.类成员的访问控制公有类型成员在关键字public后面声明，它们是类与外部的接口，任何外部函数都可以访问公有类型数据和函数 私有类型成员在关键字private后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问如果紧跟在类名称的后面声明私有成员，则关键字private可以省略数据成员尽量声明为私有成员 保护类型成员与private类似，其差别表现在继承与派生时对派生类的影响不同 3.对象类的对象是该类的某一特定实体声明形式： 类名 对象名；例：Clock myClock;类中成员互访直接使用成员名类外访问使用“对象名.成员名”方式访问 public 属性的成员 类的成员函数类的成员函数描述的是类的行为 123456class Clock &#123; public: void setTime(int newH, int newM, int newS); void showTime(); private: int hour, minute, second;&#125;; 成员函数的实现在类中说明原型，可以在类外给出函数体实现，并在函数名前使用类名加以限定 123返回值类型 类名::函数成员名（参数表）&#123; 函数体&#125; 带默认形参值的成员函数: 1234class Clock &#123; public: void setTime(int newH=0, int newM=0, int news=0); ...&#125;; 目的对象：调用成员函数时需要指出调用针对的对象 1myClock.showTime() 内联成员函数为了提高运行时的效率，对于较简单的函数可以声明为内联形式。内联函数体中不要有复杂结构（如循环语句和switch语句）。在类中声明内联成员函数的方式：隐式声明：将函数体放在类的声明中显示声明：使用inline关键字 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;class Clock&#123;public: void setTime(int newH = 0, int newM = 0, int newS = 0); void showTime();private: int hour, minute, second;&#125;void Clock::setTime(int newH, int newM, int newS) &#123; hour = newH; minute = newM; second = newS;&#125;void Clock::showTime() &#123; cout &lt;&lt; hour &lt;&lt; &quot;:&quot; &lt;&lt; minute &lt;&lt; &quot;:&quot; &lt;&lt; second;&#125;int main() &#123; Clock myClock; myClock.setTime(8, 30, 30); myClock.showTime(); return 0;&#125;//运行结果：8:30:30 构造函数构造函数的作用是在对象被创建时使用特定的值构造对象，将对象初始化为一个特定的初始状态。在对象创建时被自动调用如果程序中未声明，则系统自动产生出一个默认的构造函数，其参数列表为空 12345Class Clock &#123;public: Clock() &#123;&#125; ...&#125;; 特点：函数名与类名相同不能定义返回值类型，也不能有return语句通常声明为公有函数构造函数可以是内联函数、重载函数、带默认参数值的函数 举例： 123456789101112131415161718192021222324class Clock &#123;public: Clock(int newH,int newM,int newS);//构造函数 void setTime(int newH, int newM, int newS); void showTime();private: int hour, minute, second;&#125;;构造函数的实现：Clock::Clock(int newH, int newM, int newS): &#123; hour=newH; minute=newM; second=news; &#125;建立对象时构造函数的作用：int main() &#123; Clock c(0,0,0); //此处将自动调用构造函数 c.showTime(); return 0;&#125;//运行结果：0:0:0 析构函数完成对象被删除前的一些清理工作在对象的生存期结束的时刻系统自动调用它，然后再释放此对象所属的空间如果程序中未声明析构函数，编译器将自动产生一个隐含的析构函数不需要人为进行函数调用不接收任何参数 举例： 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;class Point &#123; public: Point(int xx,int yy); ~Point(); //...其他函数原型private: int x, y;&#125;;Point::Point(int xx,int yy) &#123; x = xx; y = yy;&#125;Point::~Point() &#123;&#125;//...其他函数的实现略 小节练习定义一个矩形类CRect，有长length和宽width。构造函数CRect(int,int)初始化矩形的长和宽，void showArea()计算并显示面积。析构函数提示”对象析构”。 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;class CRect &#123;public: CRect(int l, int w) &#123; length = l; width = w; &#125; ~CRect() &#123; cout &lt;&lt; &quot;对象析构&quot; &lt;&lt; endl; &#125; void showArea() &#123; cout &lt;&lt; &quot;Area:&quot; &lt;&lt; length * width &lt;&lt; endl; &#125;private: int length, width;&#125;;int main() &#123; int L, W; cout &lt;&lt; &quot;Input Length and Width:&quot;; cin &gt;&gt; L &gt;&gt; W; CRect c(L, W); c.showArea(); return 0;&#125; 4.构造和析构函数的延伸概念引用定义引用，就是给变量或者对象定义一个别名。如： 12int a=3;int &amp;ra=a; 那么变量a就多了一个名字ra。则下列语句等价： 12a=5;ra=5; 复制构造函数复制构造函数是一种特殊的构造函数，其形参为本类的对象引用。作用是用一个已存在的对象去初始化同类型的新对象。 12345678class 类名 &#123;public : 类名（形参）；//构造函数 类名（const 类名 &amp;对象名）；//复制构造函数，参数为引用 ...&#125;；类名::类（const 类名 &amp;对象名）//复制构造函数的实现&#123; 函数体 &#125; 复制构造函数的参数可以是常引用，也可以是非常引用。一般使用前者，这样既能以常量对象（初始化后值不能改变的对象）作为参数，也能以非常量对象作为参数去初始化其他对象。 复制构造函数被调用的三种情况:1.定义一个对象时，以本类另一个对象作为初始值，发生复制构造2.如果函数的形参是类的对象，调用函数时，将使用实参对象初始化形参对象，发生复制构造3.如果函数的返回值是类的对象，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主调函数，此时发生复制构造。 1234567891011121314151617181920212223242526272829303132333435363738class Point &#123; //Point 类的定义public: Point(int xx=0, int yy=0) &#123; x = xx; y = yy; &#125; //构造函数，内联 Point(const Point&amp; p); //复制构造函数 void setX(int xx) &#123;x=xx;&#125; void setY(int yy) &#123;y=yy;&#125; int getX() &#123; return x; &#125; int getY() &#123; return y; &#125;private: int x, y; //私有数据&#125;;//成员函数的实现Point::Point (const Point&amp; p) &#123; x = p.x; y = p.y; cout &lt;&lt; &quot;Calling the copy constructor &quot; &lt;&lt; endl;&#125;//形参为Point类对象的函数void fun1(Point p) &#123; cout &lt;&lt; p.getX() &lt;&lt; endl;&#125;//返回值为Point类对象的函数Point fun2() &#123; Point a(1, 2); return a;&#125;//主程序int main() &#123; Point a(4, 5); //第一个对象A Point b = a; //情况一，用A初始化B。第一次调用复制构造函数 cout &lt;&lt; b.getX() &lt;&lt; endl; fun1(b); //情况二，对象B作为fun1的实参。第二次调用复制构造函数 b = fun2(); //情况三，函数的返回值是类对象，函数返回时调用复制构造函数 cout &lt;&lt; b.getX() &lt;&lt; endl; return 0;&#125; 默认构造函数调用时可以不需要参数的构造函数都是默认构造函数。当不定义构造函数时，编译器自动产生默认构造函数在类中可以自定义无参数的构造函数，也是默认构造函数全部参数都有默认形参值的构造函数也是默认构造函数 下面两个都是默认构造函数，如果在类中同时出现，将产生编译错误： 12Clock();Clock(int newH=0,int newM=0,int newS=0); 函数参数传递常引用传递对象值会引起复制构造和析构，增加时间空间开销传常引用可避免这一问题。以引用做参数时，尽量使用常引用（const） 临时对象当函数返回一个对象时，会构造临时对象用以返回return a时，调用复制构造函数将a的值复制到临时对象中 1234Point fun2() &#123; Point a(1, 2); b = fun2(); return a;&#125; 编译器默认提供的函数123456class Empty&#123;public: Empty()&#123;&#125; Empty(const Empty&amp; rhs)&#123;…&#125; ~Empty()&#123;&#125; &#125;; 5.组合类中的成员数据是另一个类的对象。可以在已有抽象的基础上实现更复杂的抽象。 类组合的构造函数设计原则：不仅要负责对本类中的基本类型成员数据赋初值，也要对对象成员初始化。声明形式： 12345类名::类名(对象成员所需的形参，本类成员形参) :对象1(参数)，对象2(参数)，......&#123; //函数体其他语句&#125; 构造组合类对象时的初始化次序首先对构造函数初始化列表中列出的成员（包括基本类型成员和对象成员）进行初始化，初始化次序是成员在类体中定义的次序。 1.成员对象构造函数调用顺序：按对象成员的声明顺序，先声明者先构造。2.初始化列表中未出现的成员对象，调用用默认构造函数（即无形参的）初始化 处理完初始化列表之后，再执行构造函数的函数体。 例：线段类 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;//Point类省略//类的组合class Line &#123; //Line类的定义public: //外部接口 Line(Point xp1, Point xp2); Line(Line &amp;l); double getLen() &#123; return len; &#125;private: //私有数据成员 Point p1, p2; //Point类的对象p1,p2 double len;&#125;;//组合类的构造函数Line::Line(Point xp1, Point xp2) : p1(xp1), p2(xp2) &#123; cout &lt;&lt; &quot;Calling constructor of Line&quot; &lt;&lt; endl; double x = static_cast&lt;double&gt;(p1.getX() - p2.getX()); double y = static_cast&lt;double&gt;(p1.getY() - p2.getY()); len = sqrt(x * x + y * y);&#125;Line::Line (Line &amp;l): p1(l.p1), p2(l.p2) &#123;//组合类的复制构造函数 cout &lt;&lt; &quot;Calling the copy constructor of Line&quot; &lt;&lt; endl; len = l.len;&#125;//主函数int main&#123; Point myp1(1, 1); Point myp2(4, 5); //建立Point类的对象 Line line(myp1, myp2);//建立Line类的对象 Line line2(line); //利用复制构造函数建立一个新对象 cout &lt;&lt; &quot;The length of the line is: &quot;; cout &lt;&lt; line.getLen() &lt;&lt; endl; cout &lt;&lt; &quot;The length of the line2 is: &quot;; cout &lt;&lt; line2.getLen() &lt;&lt; endl; return 0; &#125; 前向引用声明类应该先定义，后使用如果需要在某个类的定义之前，引用该类，则应进行前向引用声明。前向引用声明只为程序引入一个标识符，但具体声明在其他地方。 123456789class B; //前向引用声明class A &#123;public: void f(B b);&#125;;class B &#123;public: void g(A a);&#125;; 二、数据的共享和保护1.标识符的作用域与可见性函数原型的作用域作用域是一个标识符在程序正文中有效的区域函数原型作用域局部作用域(块作用域)类作用域文件作用域命名空间作用域（详见第10章） 函数原型中的参数，其作用域始于”(“，结束于”)”例如，设有下列原型声明： 12double area(double radius); //radius的作用域仅在于此，不能用于程序正文其他地方 局部作用域块：一对大括号括起来的一段程序函数的形参和在块中声明的标识符，其作用域自声明处起，限于块中 123456789void fun(int a) &#123; int b = a; cin &gt;&gt; b; if (b &gt; 0) &#123; int c; //c的作用域 ...... &#125; //b的作用域&#125; //a的作用域 类的作用域类的成员具有类作用域，其范围包括类体和成员函数的函数体 如果在类作用域以外访问类的成员，要通过类名（访问静态成员），或者该类的对象名、对象引用、对象指针（访问非静态成员）类名::成员名对象名.成员名 文件的作用域不在前述各个作用域中出现的声明，就具有文件作用域 这样声明的标识符其作用域开始于声明点，结束于文件尾 可见性可见性是从对标识符的引用的角度来谈的概念 可见性表示从内层作用域向外层作用域“看”时能看见什么 如果标识在某处可见，则就可以在该处引用此标识符 标识符应声明在先，引用在后 如果某个标识符在外层中声明，且在内层中没有同一标识符的声明，则该标识符在内层可见 对于两个嵌套的作用域，如果在内层作用域内声明了与外层作用域中同名的标识符，则外层作用域的标识符在内层不可见 同一作用域中的同名标识符在同一作用域内的对象名、函数名、枚举常量名会隐藏同名的类名或枚举类型名重载的函数可以有相同的函数名 12345678910111213141516171819//5_1.cpp#include &lt;iostream&gt;using namespace std; int i; //全局变量，文件作用域int main() &#123; i = 5; //为全局变量i赋值 &#123; //子块1 int i; //局部变量，局部作用域 i = 7; cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl; &#125; cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl; return 0;&#125;/*运行结果：i = 7i = 5*/ 2.对象的生存期对象（变量）从产生到结束的这段时间就是它的生存期。在对象生存期内，对象将保持它的值，直到被更新为止 静态生存期这种生存期与程序的运行期相同在文件作用域中声明的对象具有这种生存期在函数内部声明静态生存期对象，要冠以关键字static局部作用域中的静态变量具有全局寿命，只在第一次进入函数时被初始化 123456789101112#include &lt;iostream&gt;using namespace std;int back() &#123; static int i = 5; return i;&#125;int main() &#123; cout &lt;&lt; &quot;i1 = &quot; &lt;&lt; back() &lt;&lt; endl; cout &lt;&lt; &quot;i2 = &quot; &lt;&lt; back() &lt;&lt; endl; return 0;&#125; 动态生存期块作用域中声明的，没有用static修饰的对象是动态生存期的对象（习惯称局部生存期对象）开始于程序执行到声明点时，结束于命名该标识符的作用域结束处 12345678910111213141516171819202122232425262728293031323334353637383940//5_2.cpp#include &lt;iostream&gt;using namespace std;int i = 1; // i 为全局变量，具有静态生存期void other() &#123; //a, b为静态局部变量，具有全局寿命，局部可见， //只第一次进入函数时被初始化 static int a = 2; static int b; //c为局部变量，具有动态生存期，每次进入函数时都初始化 int c = 10; a += 2; i += 32; c += 5; cout &lt;&lt; &quot;---OTHER---&quot; &lt;&lt; endl; cout &lt;&lt; &quot; i: &quot; &lt;&lt; i &lt;&lt; &quot; a: &quot; &lt;&lt; a &lt;&lt; &quot; b: &quot; &lt;&lt; b &lt;&lt; &quot; c: &quot; &lt;&lt; c &lt;&lt; endl; b = a;&#125;int main() &#123; //a为静态局部变量，具有全局寿命，局部可见 static int a; //b, c为局部变量，具有动态生存期 int b = -10; int c = 0; cout &lt;&lt; &quot;---MAIN---&quot; &lt;&lt; endl; cout &lt;&lt; &quot; i: &quot; &lt;&lt; i &lt;&lt; &quot; a: &quot; &lt;&lt; a &lt;&lt; &quot; b: &quot; &lt;&lt; b &lt;&lt; &quot; c: &quot; &lt;&lt; c &lt;&lt; endl; c += 8; other(); cout &lt;&lt; &quot;---MAIN---&quot; &lt;&lt; endl; cout &lt;&lt; &quot; i: &quot; &lt;&lt; i &lt;&lt; &quot; a: &quot; &lt;&lt; a &lt;&lt; &quot; b: &quot; &lt;&lt; b &lt;&lt; &quot; c: &quot; &lt;&lt; c &lt;&lt; endl; i += 10; other(); return 0;&#125; 3.类的静态成员如果某个属性为整个类所共有，不属于任何一个具体对象，则可声明为该类的静态成员用关键字static声明由该类的所有对象共同维护和使用，从而实现同一类不同对象之间的数据共享 静态数据成员用关键字static声明为该类的所有对象共享，静态数据成员具有静态生存期必须在类外定义和初始化，用(::)来指明所属的类 类名::标识符 例：具有静态数据成员的Point类 123456789101112131415161718192021222324252627282930313233343536373839//5_4.cpp#include &lt;iostream&gt;using namespace std; class Point &#123; //Point类定义public: //外部接口 Point(int x = 0, int y = 0) : x(x), y(y) &#123; //构造函数 //在构造函数中对count累加，所有对象共同维护同一个count count++; &#125; Point(Point &amp;p) &#123; //复制构造函数 x = p.x; y = p.y; count++; &#125; ~Point() &#123; count--; &#125; int getX() &#123; return x; &#125; int getY() &#123; return y; &#125; void showCount() &#123; //输出静态数据成员 cout &lt;&lt; &quot; Object count = &quot; &lt;&lt; count &lt;&lt; endl; &#125;private: //私有数据成员 int x, y; static int count; //静态数据成员声明，用于记录点的个数&#125;;int Point::count = 0;//静态数据成员定义和初始化，使用类名限定int main() &#123; //主函数 Point a(4, 5); //定义对象a，其构造函数回使count增1 cout &lt;&lt; &quot;Point A: &quot; &lt;&lt; a.getX() &lt;&lt; &quot;, &quot; &lt;&lt; a.getY(); a.showCount(); //输出对象个数 Point b(a); //定义对象b，其复制构造函数会使count增1 cout &lt;&lt; &quot;Point B: &quot; &lt;&lt; b.getX() &lt;&lt; &quot;, &quot; &lt;&lt; b.getY(); b.showCount(); //输出对象个数 return 0;&#125;/*运行结果：Point A: 4, 5 Object count=1Point B: 4, 5 Object count=2*/ 静态函数成员类外代码可以使用类名和作用域操作符来调用静态成员函数 静态成员函数只能引用属于该类的静态数据成员或静态函数成员 例：具有静态数据、函数成员的 Point类 1234567891011121314151617181920212223242526272829303132333435363738394041//5_5.cpp#include &lt;iostream&gt;using namespace std; class Point &#123; //Point类定义public: //外部接口 Point(int x = 0, int y = 0) : x(x), y(y) &#123; //构造函数 //在构造函数中对count累加，所有对象共同维护同一个count count++; &#125; Point(Point &amp;p) &#123; //复制构造函数 x = p.x; y = p.y; count++; &#125; ~Point() &#123; count--; &#125; int getX() &#123; return x; &#125; int getY() &#123; return y; &#125; static void showCount() &#123; //静态函数成员 cout &lt;&lt; &quot;Object count =&quot; &lt;&lt; count &lt;&lt; endl; &#125;private: //私有数据成员 int x, y; static int count; //静态数据成员声明，用于记录点的个数&#125;; int Point::count = 0;//静态数据成员定义和初始化，使用类名限定 int main() &#123; //主函数 Point::showCount(); Point a(4, 5); //定义对象a，其构造函数会使count增1 cout &lt;&lt; &quot;Point A: &quot; &lt;&lt; a.getX() &lt;&lt; &quot;, &quot; &lt;&lt; a.getY(); Point::showCount(); //输出对象个数 Point b(a); //定义对象b，其构造函数回使count增1 cout &lt;&lt; &quot;Point B: &quot; &lt;&lt; b.getX() &lt;&lt; &quot;, &quot; &lt;&lt; b.getY(); Point::showCount(); //输出对象个数 return 0;&#125;//采用静态函数成员可以不依赖于任何对象，直接访问静态数据 4.类的友元友元关系提供了不同类或对象的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制 通俗来讲，友元关系就是一个类主动声明哪些其他类或函数是它的朋友，进而给它们提供对本类的访问特许 友元是C++提供的一种破坏数据封装和数据隐藏的机制 数据隐藏和效率之间的平衡：通过将一个模块声明为另一个模块的友元，使一个模块能够引用到另一个模块中本是被隐藏的信息 为了确保数据的完整性，及数据封装与隐藏的原则，建议尽量不使用或少使用友元 友元函数友元函数是在类声明中由关键字friend修饰说明的非成员函数，在它的函数体中能够通过对象名访问private和protected成员 作用：增加灵活性，使程序员可以在封装和快速性方面做合理选择 在友元函数的函数体中访问对象中的成员必须通过对象名 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;class Point &#123; //Point类声明public: //构造函数，初始化列表 Point(int i=0, int j=0) : x(i), y(j) &#123; &#125; int getX() &#123; return x; &#125; int getY() &#123; return y; &#125; //友元函数声明 friend float dist(Point &amp;a, Point &amp;b); private: //私有数据成员 int x, y;&#125;;float dist(Point &amp;a, Point &amp;b) &#123; double x = a.x - b.x; double y = a.y - b.y; return static_cast&lt;float&gt;(sqrt(x*x+y*y));&#125;int main() &#123; Point p1(1, 1); Point p2(4, 5); cout &lt;&lt;&quot;The distance is: &quot;; cout &lt;&lt; dist(p1, p2) &lt;&lt; endl; return 0;&#125;//运行结果：The distance is: 5 友元类若一个类为另一个类的友元，则此类的所有成员都能访问对方类的私有成员和保护成员 声明语法：将友元类名在另一个类中使用friend修饰说明 1234567891011121314151617181920212223class A &#123;public: friend class B; void display() &#123; cout &lt;&lt; x &lt;&lt; endl; &#125;private: int x;&#125;class B &#123;public: void set(int i); void display();private: A a;&#125;;void B::set(int i) &#123; a.x=i;&#125;void B::display() &#123; a.display();&#125; 友元关系是不能传递的:B类是A类的友元，C类是B类的友元，没有特别声明时，C类和A类之间没有任何友元关系，不能进行数据共享 友元关系是单向的:B类是A类的友元，则B类的成员函数可以访问A类的私有和保护数据，但A类的成员函数不能访问B类的私有和保护数据 友元关系是不被继承的:B类是A类的友元，B的派生类并不会自动成为A类的友元 5.共享数据的保护对于既需要共享、又需要防止改变的数据应该声明为常类型const float PI = 3.14;常类型：常对象：必须进行初始化，不能被更新 const 类名 对象名 常成员 用const进行修饰的类成员：常数据成员和常函数成员 常引用：被引用的对象不能被更新 const 类型说明符 &amp;引用名 常数组：数组元素不能被更新(详见第6章) 类型说明符 const 数组名[大小]… 常指针：指向常量的指针(详见第6章) 常对象12345678910class A&#123;public: A(int i,int j) : x(i), y(j) &#123; &#125; ... private: int x,y;&#125;;//a是常对象，必须被初始化，不能被更新A const a(3,4); 思考：编译器做语法检查时如何保证常对象不被改变？ 常成员常成员函数（处理常对象）使用const关键字说明的函数 常成员函数说明格式：类型说明符 函数名（参数表）const;这里，const是函数类型的一个组成部分，因此在实现部分也要带const关键字 常成员函数不能更新对象的数据成员 const关键字可以用于对重载函数的区分 通过常对象只能调用它的常成员函数 常数据成员使用const说明的数据成员 12345678910111213141516171819202122232425262728293031//常成员函数举例#include&lt;iostream&gt;using namespace std;class R &#123;public: R(int r1, int r2) : r1(r1), r2(r2) &#123; &#125; void print(); void print() const;private: int r1, r2;&#125;;void R::print() &#123; cout &lt;&lt; r1 &lt;&lt; &quot;:&quot; &lt;&lt; r2 &lt;&lt; endl;&#125;//常成员函数承诺不改变对象状态（编译器审查）void R::print() const &#123; cout &lt;&lt; r1 &lt;&lt; &quot;;&quot; &lt;&lt; r2 &lt;&lt; endl;&#125;int main() &#123; R a(5,4); a.print(); //调用void print() const R b(20,52); //常成员函数用于处理常对象，常对象只能调用常成员函数 b.print(); //调用void print() const return 0;&#125;/*运行结果：5:420;52*/ 123456789101112131415161718192021222324252627282930//常数据成员举例#include &lt;iostream&gt;using namespace std;class A &#123;public: A(int i); void print();private: const int a; static const int b; //静态常数据成员&#125;;const int A::b=10; //静态常数据成员在类外说明和初始化//常数据成员只能通过初始化列表来获得初值A::A(int i) : a(i) &#123; &#125;void A::print() &#123; cout &lt;&lt; a &lt;&lt; &quot;:&quot; &lt;&lt; b &lt;&lt;endl;&#125;int main() &#123;/*建立对象a和b，并以100和0作为初值，分别调用构造函数，通过构造函数的初始化列表给对象的常数据成员赋初值*/ A a1(100); A a2(0); a1.print(); a2.print(); return 0;&#125;/*运行结果：100:100:10*/ 常引用如果在声明引用时用const修饰，被声明的引用就是常引用常引用所引用的对象不能被更新如果用常引用做形参，便不会意外地发生对实参的更改。常引用的声明形式如下： const 类型说明符 &amp;引用名;在友元函数中用常引用做参数，既能获得较高的执行效率，又能保证安全性 12345678910111213141516171819202122232425262728293031//常引用作形参#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;class Point &#123; //Point类定义public: //外部接口 Point(int x = 0, int y = 0) : x(x), y(y) &#123; &#125; int getX() &#123; return x; &#125; int getY() &#123; return y; &#125; friend float dist(const Point &amp;p1, const Point &amp;p2);private: //私有数据成员 int x, y;&#125;;//常引用作形参float dist(const Point &amp;p1, const Point &amp;p2) &#123; double x = p1.x - p2.x; double y = p1.y - p2.y; return static_cast&lt;float&gt;(sqrt(x*x+y*y));&#125;int main() &#123; const Point myp1(1, 1); const Point myp2(4, 5); cout &lt;&lt; &quot;The distance is: &quot;; cout &lt;&lt; dist(myp1, myp2) &lt;&lt; endl; return 0;&#125; //dist函数无须修改两个对象的值，因此将传参方式改为传递常引用更合适 常数组 (详见第6章)常指针 (详见第6章)6.多文件结构和编译预处理命令C++程序的一般组织结构一个源程序可以划分为多个源文件：类声明文件（.h文件）类实现文件（.cpp文件）类的使用文件（main()所在的.cpp文件） 利用工程来组合各个文件各个文件单独编写、编译，最后再连接充分利用类的封装特性在调试、修改时不用改动其他部分 123456789101112131415//多文件组织-类定义文件//文件1，类的定义，Point.hclass Point &#123; //类的定义public: //外部接口 Point(int x = 0, int y = 0) : x(x), y(y) &#123; &#125; Point(const Point &amp;p); ~Point() &#123; count--; &#125; int getX() const &#123; return x; &#125; int getY() const &#123; return y; &#125; static void showCount(); //静态函数成员private: //私有数据成员 int x, y; static int count; //静态数据成员&#125;; 12345678910111213141516//多文件组织-类实现文件//文件2，类的实现，Point.cpp#include “Point.h” //先在当前工作目录下查找#include &lt;iostream&gt; //在安装目录查找using namespace std;int Point::count = 0; //使用类名初始化静态数据成员Point::Point(const Point &amp;p) : x(p.x), y(p.y) &#123; //拷贝构造函数体 count++;&#125;void Point::showCount() &#123; cout &lt;&lt; &quot;Object count = &quot; &lt;&lt; count &lt;&lt; endl;&#125; 123456789101112131415161718//多文件组织-类使用文件//文件3，主函数，5_10.cpp#include &quot;Point.h&quot;#include &lt;iostream&gt;using namespace std;int main() &#123; Point a(4, 5); //定义对象a，其构造函数回使count增1 cout &lt;&lt; &quot;Point A: &quot; &lt;&lt; a.getX() &lt;&lt; &quot;, &quot; &lt;&lt; a.getY(); Point::showCount(); //输出对象个数 Point b(a); //定义对象b，其构造函数回使count增1 cout &lt;&lt; &quot;Point B: &quot; &lt;&lt; b.getX() &lt;&lt; &quot;, &quot; &lt;&lt; b.getY(); Point::showCount(); //输出对象个数 return 0;&#125; 外部变量与外部函数外部变量：如果一个变量除了在定义它的源文件中可以使用外，还能被其它文件使用，那么就称这个变量是外部变量 文件作用域中定义的变量，缺省情况下都是外部变量，但在其它文件中如果需要使用这一变量，需要用extern关键字加以声明 外部函数在所有类之外声明的函数（也就是非成员函数），都是具有文件作用域的 这样的函数都可以在不同的编译单元中被调用，只要在调用之前进行引用性声明（即声明函数原型）即可。也可以在声明函数原型或定义函数时用extern修饰，其效果与不加修饰的缺省状态是一样的。 将变量和函数限制在编译单元内使用匿名的命名空间：在匿名命名空间中定义的变量和函数，都不会暴露给其它的编译单元 namespace { //匿名的命名空间 int n; void f() { n++; } }这里被“namespace { …… }”括起的区域都属于匿名的命名空间，只能在当前文件中使用 标准C++库标准C++类库是一个极为灵活并可扩展的可重用软件模块的集合。标准C++类与组件在逻辑上分为6种类型：输入/输出类容器类与抽象数据类型（类模板）存储管理类算法错误处理运行环境支持 编译预处理#include 包含指令将一个源文件嵌入到当前源文件中该点处 #include&lt;文件名&gt;按标准方式搜索，文件位于C++系统目录的include子目录下 #include”文件名”首先在当前目录中搜索，若没有，再按标准方式搜索 #define 宏定义指令定义符号常量，很多情况下已被const定义语句取代定义带参数宏，已被内联函数取代 #undef删除由#define定义的宏，使之不再起作用 #if 和 #endif条件编译指令 12345#if 常量表达式//当“ 常量表达式”非零时编译 程序正文 #endif...... 继承在已有类的基础上，进行扩展形成新的类特殊和一般的关系，既共享一般的属性和行为，又具有特殊的属性和行为C++中支持层次分类的一种机制，允许程序员在保持原有类特性的基础上，进行更具体的说明 多态广义含义：使一段程序能够处理多种类型对象的能力 目的：达到行为标识统一，减少程序中标识符的个数 实现：重载函数和虚函数——见第8章","categories":[],"tags":[]},{"title":"树莓派配置","slug":"树莓派配置","date":"2021-04-29T13:36:08.413Z","updated":"2021-04-29T14:54:55.987Z","comments":true,"path":"2021/04/29/树莓派配置/","link":"","permalink":"https://daftpumpkin.github.io/2021/04/29/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E7%BD%AE/","excerpt":"第一次使用树莓派 一、系统的选择1.根据自己需求选择下载系统，可以在树莓派官网：https://www.raspberrypi.org/ 查看对应的系统，这里使用官方推荐的系统：Raspberry Pi OS在官网下载种子以后使用其他下载工具可以加速下载。 2.制作系统：使用到balenaEtcher这个软件，一键烧录到TF卡，十分方便。 3.接好外设，上电，先不必配置，因为不换源的话是无法update的。 二、换源：这里选择清华源：https://mirror.tuna.tsinghua.edu.cn/help/raspbian/（1）在命令行窗口内输入 sudo nano /etc/apt/sources.list 并回车，进入编辑器。（nano是系统内置的轻量化文本编辑器） （2）按照清华源网站中给出的网址修改，按 ctrl-o 保存，按 ctrl-x 关闭。 （3）同样的方法，把 /etc/apt/sources.list.d/raspi.list 文件也替换好。 （4）惯例：sudo apt-get update","text":"第一次使用树莓派 一、系统的选择1.根据自己需求选择下载系统，可以在树莓派官网：https://www.raspberrypi.org/ 查看对应的系统，这里使用官方推荐的系统：Raspberry Pi OS在官网下载种子以后使用其他下载工具可以加速下载。 2.制作系统：使用到balenaEtcher这个软件，一键烧录到TF卡，十分方便。 3.接好外设，上电，先不必配置，因为不换源的话是无法update的。 二、换源：这里选择清华源：https://mirror.tuna.tsinghua.edu.cn/help/raspbian/（1）在命令行窗口内输入 sudo nano /etc/apt/sources.list 并回车，进入编辑器。（nano是系统内置的轻量化文本编辑器） （2）按照清华源网站中给出的网址修改，按 ctrl-o 保存，按 ctrl-x 关闭。 （3）同样的方法，把 /etc/apt/sources.list.d/raspi.list 文件也替换好。 （4）惯例：sudo apt-get update 三、配置系统：（1）更改显存大小，需要图形化操作界面和播放视频一般需要512Mb的显存。 （2）在sudo raspi-config下的进阶选项中扩展文件空间 （3）在命令行模式中使用sudo raspi config进入配置菜单，将显示分辨率和去黑边等配置好。（也可以通过图形化界面中的设置菜单调整） （3）安装中文输入法：谷歌拼音输入法： apt install -y fcitx fcitx-googlepinyinreboot生效 重启完成后需要添加一下中文输入法，点击左上角树莓图标进入Preference -&gt; Fcitx Configuration 可以利用跟Windows切换输入法一样Ctrl + 空格来切换输入法了。 散热贴是很有必要的：查看温度的指令：vcgencmd measure_temp 四、部署本地有线SSH和VNC1.在控制台sudo raspi-config打开设置菜单&gt;interface options中打开SSH和VNC 2.插接好网口，共享以太网：这样树莓派就可以使用笔记本连接上的WIFI了 3.查看树莓派网口的ip：是在192.168.0.1端口下 那么再打开cmd，执行arp -a在192.168.0.1端口下第一个ip即是树莓派的ip地址，复制到puTTy和VNC Viewer中就可以访问树莓派了 五、部署无线SSH和VNC1.打开命令行，输入以下命令，sudo nano /etc/dhcpcd.conf2.将WLAN0的静态IP设置到如下图，我们电脑的同一网段之下： 3.reboot以后使用ifconfig查看WLAN的IP是否已经设置成功。 4.打开puTTY或者VNC Viewer就可以连接到树莓派了。 注意：手动静态IP要注意不能跟路由器DHCP所自动分配的IP冲突，否则树莓派就有可能无法正常联网。还有要跟电脑同一网段，否则无法远程登陆。 六、备份配置好的系统镜像可以使用树莓派自带的 SD Card Copier对系统进行备份。","categories":[],"tags":[]},{"title":"picamera的相关接口","slug":"picamera的相关接口","date":"2021-04-29T13:35:12.701Z","updated":"2021-04-29T14:09:12.404Z","comments":true,"path":"2021/04/29/picamera的相关接口/","link":"","permalink":"https://daftpumpkin.github.io/2021/04/29/picamera%E7%9A%84%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3/","excerpt":"摄像头的驱动方法1. 硬件连接：把摄像头的排线插入到网口和 HDMI 口之间的排线插槽，银色亮面朝向 HDMI 口。需要先把树莓 派板载的排线插槽的扣子拨开，才能插入排线。排线需要紧密插入排线插槽，同时应注意避免排 线折弯。排线插入之后，需要把插槽的扣子重新扣上。 2. 软件驱动：1.进入Raspbian系统终端，更新系统： 12apt-get update apt-get upgrade 2.进入摄像头配置选项： sudo raspi-config依次选择： 1Interfacing Options --&gt; Camera --&gt; Would you like the camera interface to be enabled? &lt;Yes&gt; 3.重启系统： sudo reboot 配置完成。 4.在命令行中： 12vcgencmd get_camerasupported&#x3D;1 detected&#x3D;1 说明摄像头连接成功。 3. 控制台中对摄像头的基本操作1.拍照： raspistill -o image.jpg此处image.jpg 是照片文件名。 2.录像： raspivid -o video.h264 -t 10000其中 -t 10000 表示录制 10 秒，用户各根据自己的需要进行调整。#使用Python控制摄像头#","text":"摄像头的驱动方法1. 硬件连接：把摄像头的排线插入到网口和 HDMI 口之间的排线插槽，银色亮面朝向 HDMI 口。需要先把树莓 派板载的排线插槽的扣子拨开，才能插入排线。排线需要紧密插入排线插槽，同时应注意避免排 线折弯。排线插入之后，需要把插槽的扣子重新扣上。 2. 软件驱动：1.进入Raspbian系统终端，更新系统： 12apt-get update apt-get upgrade 2.进入摄像头配置选项： sudo raspi-config依次选择： 1Interfacing Options --&gt; Camera --&gt; Would you like the camera interface to be enabled? &lt;Yes&gt; 3.重启系统： sudo reboot 配置完成。 4.在命令行中： 12vcgencmd get_camerasupported&#x3D;1 detected&#x3D;1 说明摄像头连接成功。 3. 控制台中对摄像头的基本操作1.拍照： raspistill -o image.jpg此处image.jpg 是照片文件名。 2.录像： raspivid -o video.h264 -t 10000其中 -t 10000 表示录制 10 秒，用户各根据自己的需要进行调整。#使用Python控制摄像头# 使用Python控制摄像头（piccamera库）快速总览：123456789101112131415import picameracamera = picamera.PiCamera()camera.saturation = 80 # 设置图像视频的饱和度camera.brightness = 50 # 设置图像的亮度(50表示白平衡的状态)camera.shutter_speed = 6000000 # 相机快门速度 数值越大，曝光时间越长camera.iso = 800 # ISO标准实际上就是来自胶片工业的标准称谓，ISO是衡量胶片对光线敏感程度的标准。如50 ISO, 64 ISO, 100 ISO表示在曝光感应速度上要比高数值的来得慢，高数值ISO是指超过200以上的标准，如200 ISO, 400 ISOcamera.sharpness = 0 #设置图像的锐度值，默认是0，取值范围是-100~100之间camera.framrate = 32 #这里可能用的Fraction是一个分数模块来存储分数1/6，保证分数运算的精度(记得调用模块：from fractions import Fraction) camera.hflip = True # 是否进行水平翻转 camera.vflip = False #是否进行垂直翻转 camera.rotation = 0 #是否对图像进行旋转camera.resolution = (280,160) #设置图像的width和height a_gain = camera.analog_gain #这个值表示摄像头传感器件到数字装换之前的模拟信号的增益，格式是Fraction的格式 一般似乎也用不上d_gain = camera.digital_gain #这个值表示摄像头的数字增益大小 一般似乎也用不上 ISO感光度的设置技巧一般白天光线充足的情况ISO是100到200。在黑暗的条件下（如下雨天），ISO调到300-400，比较暗调到800，灯光非常暗（太阳下山后），调到1000以上，拍夜景（如夜间庆典、演唱会）调到1600以上。ISO调到越高，拍出来的照片噪点就越多，所以ISO不是越高越好，只是在光线不足的情况下使用，并且尽可能调低ISO数值。 快门速度的设置技巧一般情况下，正常快门速度是在60分之一秒到80分之一秒。拍摄行人、阴天或者日落时候的运动对象快门速度1/125秒。拍摄高速运动的物体或画面，快门速度360/1秒~600/1秒。如拍打篮球的画面。拍摄下落的水滴需要1/1000秒。拍绸缎感的流水，或者夜景汽车灯河用慢速快门。拍运动定格用快速快门。室外光线条件好，则快门可以较快，光线暗则要放慢快门速度。快门数一般是没用常用的，你要是想设置为默认快门，那么就是用A档或是自动挡吧！只有这两个档位是默认快门数。像S档和M档都是可以设置快门速度的。 拍照与实时视频123camera.capture(&#x27;test.jpg&#x27;, use_video_port = False) #拍摄一张图片，图片的名称为test.jpg use_video_port用来指定是通过视频接口来使用还是普通的接口，详解如下camera.capture_continuous(rawCapture, format=&quot;bgr&quot;, use_video_port=True) #连续的拍摄一组视频帧，将每一帧都存储在rawCapture这个变量当中，存储的格式是bgr的格式，使用了摄像头的接口 1234capture(output, format=None, use_video_port=False, resize=None, splitter_port=0, bayer=False, \\*\\*options) #从摄像头中获得一张图像，将这张图像存储在output当中.capture_continuous(output, format=None, use_video_port=False, resize=None, splitter_port=0, burst=False, bayer=False, \\*\\*options) #从摄像头上获取连续的视频流，相关的参数和上面的函数相似 参数output是一个用来保存图像数据的区域：output为字符串string的时候，表示将得到的数据写入到文件名是string文件当中output是一个可以写入的对象时，就相当于将图像的数据追加append到对象的后面output也可以是一个具有buffer protocal数据类型的数据(要保证足够大的写入空间来保存图像)参数format是表示文件的类型，主要有下面的文件类型：‘jpeg’ - Write a JPEG file‘png’ - Write a PNG file‘gif’ - Write a GIF file‘bmp’ - Write a Windows bitmap file‘yuv’ - Write the raw image data to a file in YUV420 format‘rgb’ - Write the raw image data to a file in 24-bit RGB format‘bgr’ - Write the raw image data to a file in 24-bit BGR format 参数use_video_port用来表示获取图像的端口：True 表示从视频端口获取图像，这个时候为了保证视频的帧速，画质就会降低False 表示从标准的端口获取图像，图像的质量较高，获取的时间较长 录制视频12camera.start_recording(&#x27;Video.mjpeg&#x27;,format = &#x27;mjpeg&#x27;) # 开始进行录制视频的参数设置，param1是录制视频的文件名 param2是设置录制文件的格式 param3是录制视频的尺寸大小，详细如下解释camera.wait_recording(20) # 启动开始录制，等待总共录制的时间为20s 主要单位是s秒camera.stop_recording() # 停止视频的录制功能 123456from picamera import PiCamerafrom time import sleepcamera = PiCamera()camera.start_preview()sleep(5)camera.stop_preview() 进入终端，执行： 1python3 Desktop&#x2F;camera.py 桌面将弹出预览框，实时取景并预览 需要注意的是，预览框仅在直接连接屏幕时有效，而是使用VNC等软件远程连接树莓派桌面，则不会弹出该预览框 如果预览画面是上下颠倒的，则可以通过以下代码旋转180度： 12camera = PiCamera()camera.rotation = 180 预览画面可旋转90度、180度、270度如果要重置画面，可将画面旋转0度 设置预览框的透明度： 1camera.start_preview(alpha=100) #alpha的值范围是0-255 1.拍照在预览代码的中间插入camera.capture()命令 1234camera.start_preview()sleep(5)camera.capture(&#x27;/home/pi/Desktop/image.jpg&#x27;)camera.stop_preview() 请注意：必须要执行代码sleep(5)，以便给摄像头的传感器留下一定时间调整亮度和白平衡 2.录像移除 camera.captue()，并加入camera.start_recording()和camera.stop_recording() 12345camera.start_preview()camera.start_recording(&#x27;/home/pi/Desktop/video.mp4&#x27;)sleep(5)||camera.wait_recording(5)camera.stop_recording()camera.stop_preview() 以上代码执行后，将在桌面生成video.mp4的视频，长度为5秒 3.更多参数设置picamera可以给图片添加很多参数 设置分辨率默认情况下，图片的分辨率等于显示器的分辨率，但最大的图像尺寸不超过2592*1944 像素，视屏尺寸不超过1920*1080像素；图像和视屏的最小尺寸则为64*64像素。 可使用如下代码设置图像的分辨率： 123456camera.resolution = (2592, 1944)camera.framerate = 15camera.start_preview()sleep(5)camera.capture(&#x27;/home/pi/Desktop/max.jpg&#x27;)camera.stop_preview() 注意：相机的帧数需要设置为≤15帧，以支持最大分辨率。 给图片添加文字123456camera.start_preview()camera.annotate_text = &quot;Hello world!&quot;sleep(5)camera.capture(&#x27;/home/pi/Desktop/text.jpg&#x27;)camera.stop_preview() 1.文字大小可以自定义12camera.annotate_text_size = 50 #annotate_text_size的取值范围为6-160，默认值32 2.文字颜色自定义123456camera.start_preview()camera.annotate_background = Color(&#x27;blue&#x27;)camera.annotate_foreground = Color(&#x27;yellow&#x27;)camera.annotate_text = &quot; Hello world &quot;sleep(5)camera.stop_preview() 修改图片的参数1.亮度12345camera.start_preview()camera.brightness = 70sleep(5)camera.capture(&#x27;/home/pi/Desktop/bright.jpg&#x27;)camera.stop_preview() brightness的取值范围为0-100，默认值50 2.对比度12 camera.contrast = 50 #contrast的取值范围为0-100，默认值50 3.风格可通过camera.image_effect，给图片添加特效： 12345678910111213141516171819202122232425有效值：none(默认)negativesolarizesketchdenoiseembossoilpainthatchgpenpastelwatercolorfilmblursaturationcolorswapwashedoutposterisecolorpointcolorbalancecartoondeinterlace1deinterlace2 例如： 12345camera.start_preview()camera.image_effect = &#x27;colorswap&#x27;sleep(5)camera.capture(&#x27;/home/pi/Desktop/colorswap.jpg&#x27;)camera.stop_preview() 4.模式可使用camera.exposure_mode，设置拍照模式（如夜晚、运动、雪地等模式） 123456789101112131415有效值：offauto(默认)nightnightpreviewbacklightspotlightsportssnowbeachverylongfixedfpsantishakefireworks 例如： 12345camera.start_preview()camera.exposure_mode = &#x27;beach&#x27;sleep(5)camera.capture(&#x27;/home/pi/Desktop/beach.jpg&#x27;)camera.stop_preview() 5.白平衡可使用camera.awb_mode设置白平衡 123456789101112有效值：offauto(默认)sunlightcloudyshadetungstenfluorescentincandescentflashhorizon 例如设置白平衡为“白天” 12345camera.start_preview()camera.awb_mode = &#x27;sunlight&#x27;sleep(5)camera.capture(&#x27;/home/pi/Desktop/sunlight.jpg&#x27;)camera.stop_preview()","categories":[],"tags":[]},{"title":"在Android上运行VScode","slug":"在Android上运行VScode","date":"2021-04-29T13:33:43.526Z","updated":"2021-04-29T14:10:07.828Z","comments":true,"path":"2021/04/29/在Android上运行VScode/","link":"","permalink":"https://daftpumpkin.github.io/2021/04/29/%E5%9C%A8Android%E4%B8%8A%E8%BF%90%E8%A1%8CVScode/","excerpt":"","text":"在Android上运行VScodetermux-ubuntu项目地址：https://github.com/Neo-Oli/termux-ubuntu code-server项目地址：https://github.com/cdr/code-server 1.下载安装termux因为网络问题install失败，可以在这个网址直接下载完整的安装包：https://f-droid.org/packages/com.termux/ 2.安装ubuntu12345678910pkg updatepkg install wget proot&lt;!--more--&gt;在想要安装的目录下：mkdir -p -&#x2F;jails&#x2F;ubuntucd ~&#x2F;jails&#x2F;ubuntuweget https:&#x2F;&#x2F;github.com&#x2F;Neo-Oli&#x2F;termux-ubuntu&#x2F;master.ubuntu.shbash ubuntu.sh 此脚本中下载ubuntu包的地址已经过期，但是配置操作可以继续执行，在bash前需要先手动下载ubuntu包： 1wget &quot;https:&#x2F;&#x2F;partner-images.canonical.com&#x2F;core&#x2F;focal&#x2F;current&#x2F;ubuntu-focal-core-cloudimg-arm64-root.tar.gz&quot; -O ubuntu.tar.gz 运行脚本后，使用./start-ubuntu.sh即可开启root的ubuntu系统 3.配置ubuntu12apt updateapt upgrade 4.安装code-server在code-server的GitHub的Realease中可以找到最新版arm-64bit的地址，直接使用weget指令下载code-server 解压，运行code-server： 123tar -xvf.&#x2F;code-server --auth none 5..开启VSCode本地服务器开启以后即可在浏览器的http://localhost:8080中打开vscode","categories":[],"tags":[]},{"title":"计网复习","slug":"计网复习","date":"2021-04-29T13:31:54.424Z","updated":"2021-04-29T14:09:40.516Z","comments":true,"path":"2021/04/29/计网复习/","link":"","permalink":"https://daftpumpkin.github.io/2021/04/29/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/","excerpt":"计网复习 [toc] TCP/IP协议簇是互联网的基石 位Bit——&gt;0/1字节Byte——&gt;8个位字Word——&gt;16个位/2字节双字DWord——&gt;32个位/4字节/2字 一、TCP/IP协议体系的认知：TCP/IP是封装于系统内，属于内核态的协议栈。TCP/IP协议在一定程度上参考了OSI的体系结构。OSI模型共有七层，从下到上分别是：物理层、数据链路层、网络层、运输层、会话层、表示层和应用层。但是这显然是有些复杂的，所以在TCP/IP协议中，它们被简化为了四个层次。 （1）应用层、表示层、会话层三个层次提供的服务相差不是很大，所以在TCP/IP协议中，它们被合并为应用层一个层次。 [1] （2）由于运输层和网络层在网络协议中的地位十分重要，所以在TCP/IP协议中它们被作为独立的两个层次。 [1] （3）因为数据链路层和物理层的内容相差不多，所以在TCP/IP协议中它们被归并在网络接口层一个层次里。只有四层体系结构的TCP/IP协议，与有七层体系结构的OSI相比要简单了不少，也正是这样，TCP/IP协议在实际的应用中效率更高，成本更低。","text":"计网复习 [toc] TCP/IP协议簇是互联网的基石 位Bit——&gt;0/1字节Byte——&gt;8个位字Word——&gt;16个位/2字节双字DWord——&gt;32个位/4字节/2字 一、TCP/IP协议体系的认知：TCP/IP是封装于系统内，属于内核态的协议栈。TCP/IP协议在一定程度上参考了OSI的体系结构。OSI模型共有七层，从下到上分别是：物理层、数据链路层、网络层、运输层、会话层、表示层和应用层。但是这显然是有些复杂的，所以在TCP/IP协议中，它们被简化为了四个层次。 （1）应用层、表示层、会话层三个层次提供的服务相差不是很大，所以在TCP/IP协议中，它们被合并为应用层一个层次。 [1] （2）由于运输层和网络层在网络协议中的地位十分重要，所以在TCP/IP协议中它们被作为独立的两个层次。 [1] （3）因为数据链路层和物理层的内容相差不多，所以在TCP/IP协议中它们被归并在网络接口层一个层次里。只有四层体系结构的TCP/IP协议，与有七层体系结构的OSI相比要简单了不少，也正是这样，TCP/IP协议在实际的应用中效率更高，成本更低。 二、数据链路层（从底层往高层 ）1.以太网帧的格式：以太网链路传输的数据包称做以太帧，或者以太网数据帧。在以太网中，网络访问层的软件必须把数据转换成能够通过网络适配器硬件进行传输的格式。 以太帧的工作机制：当以太网软件从网络层接收到数据报之后，需要完成如下操作： 根据需要把网际层的数据分解为较小的块，以符合以太网帧数据段的要求。以太网帧的整体大小必须在 64～1518 字节之间（不包含前导码）。有些系统支持更大的帧，最大可以支持 9000 字节。有些系统支持更大的帧，最大可以支持 9000 字节。 把数据块打包成帧。每一帧都包含数据及其他信息，这些信息是以太网网络适配器处理帧所需要的。 把数据帧传递给对应于 OSI 模型物理层的底层组件，后者把帧转换为比特流，并且通过传输介质发送出去。 以太网上的其他网络适配器接收到这个帧，检查其中的目的地址。如果目的地址与网络适配器的地址相匹配，适配器软件就会处理接收到的帧，把数据传递给协议栈中较高的层。 802.3协议以太网帧格式 参考于https://www.pianshen.com/article/532043479/ CRC循环冗余检验 https://www.bilibili.com/video/BV1Jz4y1C7La?p=2&amp;share_source=copy_web 2.最大传输单元（MTU）：用来通知对方所能接受数据服务单元的最大尺寸，说明发送方能够接受的有效载荷大小。 是包或帧的最大长度，一般以字节记。如果MTU过大，在碰到路由器时会被拒绝转发，因为它不能处理过大的包。如果太小，因为协议一定要在包(或帧)上加上包头，那实际传送的数据量就会过小，这样也划不来。大部分操作系统会提供给用户一个默认值，该值一般对用户是比较合适的。 802.3对数据帧的长度都有一个限制，其最大值分别是1500字节和1492字节。链路层的这个特性称为MTU，即最大传输单元。不同类型网络的数帧长度大多数都有一个上限。如果IP层有一个数据报要传，而且数据帧的长度比链路层的MTU还大，那么IP层就需要进行分片( fragmentation)，即把数据报分成干片，这样每一片就都小于MTU。 3.ARP/RARP协议：ARPARP协议是“Address Resolution Protocol”（地址解析协议）的缩写。其作用是在以太网环境中，数据的传输所依懒的是MAC地址而非IP地址，而将已知IP地址转换为MAC地址的工作是由ARP协议来完成的。 根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的 OSI模型把网络工作分为七层，IP地址在OSI模型的第三层，MAC地址在第二层，彼此不直接打交道。在通过以太网发送IP数据包时，需要先封装第三层（32位IP地址）、第二层（48位MAC地址）的报头，但由于发送时只知道目标IP地址，不知道其MAC地址，又不能跨第二、三层，所以需要使用地址解析协议。使用地址解析协议，可根据网络层IP数据包包头中的IP地址信息解析出目标硬件地址（MAC地址）信息，以保证通信的顺利进行。 1.报文格式 2.ARP查询原理 主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程： 第1步：根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。 第2步：如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。 第3步：主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。 第4步：主机B将包含其MAC地址的ARP回复消息直接发送回主机A。 第5步：当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。 3.ARP缓存 ARP缓存是个用来储存IP地址和MAC地址的缓冲区，其本质就是一个IP地址–&gt;MAC地址的对应表，表中每一个条目分别记录了网络上其他主机的IP地址和对应的MAC地址。每一个以太网或令牌环网络适配器都有自己单独的表。当地址解析协议被询问一个已知IP地址节点的MAC地址时，先在ARP缓存中查看，若存在，就直接返回与之对应的MAC地址，若不存在，才发送ARP请求向局域网查询。为使广播量最小，ARP维护IP地址到MAC地址映射的缓存以便将来使用。ARP缓存可以包含动态和静态项目。动态项目随时间推移自动添加和删除。每个动态ARP缓存项的潜在生命周期是10分钟。新加到缓存中的项目带有时间戳，如果某个项目添加后2分钟内没有再使用，则此项目过期并从ARP缓存中删除；如果某个项目已在使用，则又收到2分钟的生命周期；如果某个项目始终在使用，则会另外收到2分钟的生命周期，一直到10分钟的最长生命周期。静态项目一直保留在缓存中，直到重新启动计算机为止。 RARP地址解析协议是根据IP地址获取物理地址的协议，而反向地址转换协议（RARP）是局域网的物理机器从网关服务器的ARP表或者缓存上根据MAC地址请求IP地址的协议，其功能与地址解析协议相反。与ARP相比，RARP的工作流程也相反。首先是查询主机向网路送出一个RARP Request广播封包，向别的主机查询自己的IP地址。这时候网络上的RARP服务器就会将发送端的IP地址用RARP Reply封包回应给查询者，这样查询主机就获得自己的IP地址了。 三、网络层不同于电信网的面向连接的通信方式所提供的可靠传输的服务，网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。 IP位于TCP/IP模型的网络层(相当于OSI模型的网络层)，它可以向传输层提供各种协议的信息，例如TCP、UDP等；对下可将IP信息包放到链路层，通过以太网、令牌环网络等各种技术来传送。 为了能适应异构网络，IP强调适应性、简洁性和可操作性，并在可靠性做了一定的牺牲。IP不保证分组的交付时限和可靠性，所传送分组有可能出现丢失、重复、延迟或乱序等问题。 1.IP首部格式： 16位分片标识DF不分片标志MF更多分片标志13位片偏移8位生存时间TTL16位的首部检验和 2.IP分片：当IP数据报超过帧的MTU(1500)(最大传输单元)时，它将会被分片传输。分片能发生在发送端或者中转路由器，且在传输过程中可能被多次分片。在最后的目标机器上这些分片才会被内核的的IP模块重新组装。 分片情况IP分片发生在IP层，不仅源端主机会进行分片，中间的路由器也有可能分片，因为不同的网络的MTU是不一样的，如果传输路径上的某个网络的MTU比源端网络的MTU要小，路由器就可能对IP数据报再次进行分片。而分片数据的重组只会发生在目的端的IP层。 一般IP首部为20字节，UDP首部为8字节，数据的净荷（payload）部分预留是1500-20-8=1472字节。如果数据部分大于1472字节，就会出现分片现象。 在IP首部有4个字节是用于分片的，如下图所示。前16位是IP数据报的标识，同一个数据报的各个分片的标识是一样的，目的端会根据这个标识来判断IP分片是否属于同一个IP数据报。中间3位是标志位，其中有1位用来表示是否有更多的分片，如果是最后一个分片，该标志位为0，否则为1。后面13位表示分片在原始数据的偏移，这里的原始数据是IP层收到的传输的TCP或UDP数据，不包含IP首部。需要注意的，在分片的数据中，传输层的首部只会出现在第一个分片中，如下图所示。因为传输层的数据格式对IP层是透明的，传输层的首部只有在传输层才会有它的作用，IP层不知道也不需要保证在每个分片中都有传输层首部。所以，在网络上传输的数据包是有可能没有传输层首部的。 如何避免IP分片在网络编程中，我们要避免出现IP分片，那么为什么要避免呢？原因是IP层是没有超时重传机制的，如果IP层对一个数据包进行了分片，只要有一个分片丢失了，只能依赖于传输层进行重传，结果是所有的分片都要重传一遍，这个代价有点大。由此可见，IP分片会大大降低传输层传送数据的成功率，所以我们要避免IP分片。对于UDP包，我们需要在应用层去限制每个包的大小，一般不要超过1472字节，即以太网MTU（1500）—UDP首部（8）—IP首部（20）。对于TCP数据，应用层就不需要考虑这个问题了，因为传输层已经帮我们做了。在建立连接的三次握手的过程中，连接双方会相互通告MSS（Maximum Segment Size，最大报文段长度），MSS一般是MTU—IP首部（20）—TCP首部（20），每次发送的TCP数据都不会超过双方MSS的最小值，所以就保证了IP数据报不会超过MTU，避免了IP分片。 如何确定分片顺序接收端如何确定所有分片都到达IP选路路由表的含义3.ICMP协议：ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。 ICMP使用IP的基本支持，就像它是一个更高级别的协议，但是，ICMP实际上是IP的一个组成部分，必须由每个IP模块实现。 ICMP报文格式ICMP报文包含在IP数据报中，属于IP的一个用户，IP头部就在ICMP报文的前面，所以一个ICMP报文包括IP头部、ICMP头部和ICMP报文，IP头部的Protocol值为1就说明这是一个ICMP报文，ICMP头部中的类型（Type）域用于说明ICMP报文的作用及格式，此外还有一个代码（Code）域用于详细说明某种ICMP报文的类型，所有数据都在ICMP头部后面。 ICMP报文分两类：查询(2种)+查错(5种)四、传输层1.UDP协议的特点Internet 的传输层有两个主要协议，互为补充。无连接的是 UDP，它除了给应用程序发送数据包功能并允许它们在所需的层次上架构自己的协议之外，几乎没有做什么特别的事情。面向连接的是 TCP，该协议几乎做了所有的事情。 用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。它主要用于不要求分组顺序到达的传输中，分组传输顺序的检查与排序由应用层完成，提供面向事务的简单不可靠信息传送服务。UDP 协议基本上是IP协议与上层协议的接口。UDP协议适用端口分别运行在同一台设备上的多个应用程序。 首部字段 2.TCP协议特点 传输控制协议（TCP，Transmission Control Protocol）是为了在不可靠的互联网络上提供可靠的端到端字节流而专门设计的一个传输协议。 首部字段可靠机制 3.TCP的连接控制：三次握手TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN+ACK，并最终对对方的 SYN 执行 ACK 确认。这种建立连接的方法可以防止产生错误的连接，TCP使用的流量控制协议是可变大小的滑动窗口协议。 TCP三次握手的过程如下：1.客户端发送SYN（SEQ=x）报文给服务器端，进入SYN_SEND状态。2.服务器端收到SYN报文，回应一个SYN （SEQ=y）ACK（ACK=x+1）报文，进入SYN_RECV状态。3.客户端收到服务器端的SYN报文，回应一个ACK（ACK=y+1）报文，进入Established状态。三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。 四次挥手建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由TCP的半关闭（half-close）造成的。具体过程如下图所示。 某个应用进程首先调用close，称该端执行“主动关闭”（active close）。该端的TCP于是发送一个FIN分节，表示数据发送完毕。 接收到这个FIN的对端执行 “被动关闭”（passive close），这个FIN由TCP确认。注意：FIN的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因为，FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。 一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。 接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN。既然每个方向都需要一个FIN和一个ACK，因此通常需要4个分节。 同时打开同时关闭半关闭 4.TCP流量控制机制：滑动窗口慢启动拥塞避免快速重传快速恢复 5.超时重传机制：各种定时器 6.面试中常见的问题：1.为什么需要3次握手，4次挥手https://blog.csdn.net/xifeijian/article/details/12777187 2.为什么TCP/UDP都存在伪包头UDP计算校验和的方法和计算IP数据报首部校验和的方法相似。 但不同的是：IP数据报的校验和只检验IP数据报的首部，但UDP的校验和是将首部和数据部分一起都检验。 在发送端，首先是将全零放入检验和字段。再将伪首部以及UDP用户数据报看成是由许多16bit的字串接起来。 若UDP用户数据报的数据部分不是偶数个字节，则要填入一个全零字节(即：最后一个基数字节应是16位数的高字节而低字节填0)。 然后按二进制反码计算出这些16bit字的和(两个数进行二进制反码求和的运算的规则是：从低位到高位逐列进行计算。 0和0相加是0，0和1相加是1，1和1相加是0但要产生一个进位1，加到下一列。若最高位相加后产生进位，则最后得到的结果要加1)。 将此和的二进制反码写入校验和字段后，发送此UDP用户数据报。 在接收端，将收到的UDP用户数据报连同伪首部(以及可能的填充全零字节)一起，按二进制反码求这些16bit字的和。 当无差错时其结果应全为1。否则就表明有差错出现， 接收端就应将此UDP用户数据报丢弃(也可以上交给应用层，但附上出现了差错的警告)。 TCP 的校验和计算方法同UDP一样，同样要加上一个伪头部，区别是伪头部的协议码是0x06，长度是整个TCP报文的长度（包含TCP头部）。 ICMP的校验和 ICMP校验和的计算方法一样，只不过只是对ICMP包整个进行校验和，没有伪头部，也不包括IP包头部。 3.TCP与UDP的对比TCP 是面向连接的传输控制协议，而UDP 提供了无连接的数据报服务；TCP 具有高可靠性，确保传输数据的正确性，不出现丢失或乱序；UDP 在传输数据前不建立连接，不对数据报进行检查与修改，无须等待对方的应答，所以会出现分组丢失、重复、乱序，应用程序需要负责传输可靠性方面的所有工作；UDP 具有较好的实时性，工作效率较 TCP 协议高；UDP 段结构比 TCP 的段结构简单，因此网络开销也小。TCP 协议可以保证接收端毫无差错地接收到发送端发出的字节流，为应用程序提供可靠的通信服务。对可靠性要求高的通信系统往往使用 TCP 传输数据。比如 HTTP 运用 TCP 进行数据的传输。 五、应用层1.DNS：域名系统(Domain Name System,DNS)是Internet上解决网上机器命名的一种系统。就像拜访朋友要先知道别人家怎么走一样，Internet上当一台主机要访问另外一台主机时，必须首先获知其地址，TCP/IP中的IP地址是由四段以“.”分开的数字组成(此处以IPv4的地址为例，IPv6的地址同理)，记起来总是不如名字那么方便，所以，就采用了域名系统来管理名字和IP的对应关系。 DNS的名字空间DNS指针查询（反向查找或逆向解析）的基本原理DNS缓存 2.FTP协议：控制连接+数据连接，为什么需要控制流数据流两种工作模式：PASV+PORT各种FTP指令和响应码FTP断点续传，匿名FTP 3.HTTP协议：超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使开发和部署非常地直截了当。 HTTP是基于客户/服务器模式，且面向连接的。典型的HTTP事务处理有如下的过程： [7] （1）客户与服务器建立连接；（2）客户向服务器提出请求；（3）服务器接受请求，并根据请求返回相应的文件作为应答；（4）客户与服务器关闭连接。客户与服务器之间的HTTP连接是一种一次性连接，它限制每次连接只处理一个请求，当服务器返回本次请求的应答后便立即关闭连接，下次请求再重新建立连接。这种一次性连接主要考虑到WWW服务器面向的是Internet中成干上万个用户，且只能提供有限个连接，故服务器不会让一个连接处于等待状态，及时地释放连接可以大大提高服务器的执行效率。 [7] HTTP是一种无状态协议，即服务器不保留与客户交易时的任何状态。这就大大减轻了服务器记忆负担，从而保持较快的响应速度。HTTP是一种面向对象的协议。允许传送任意类型的数据对象。它通过数据类型和长度来标识所传送的数据内容和大小，并允许对数据进行压缩传送。当用户在一个HTML文档中定义了一个超文本链后，浏览器将通过TCP/IP协议与指定的服务器建立连接。 [7] HTTP支持持久连接，在HTTP / 0.9和1.0中，连接在单个请求/响应对之后关闭。在HTTP / 1.1中，引入了保持活动机制，其中连接可以重用于多个请求。这样的持久性连接可以明显减少请求延迟，因为在发送第一个请求之后，客户端不需要重新协商TCP 3-Way-Handshake连接。另一个积极的副作用是，通常，由于TCP的缓慢启动机制，连接随着时间的推移而变得更快。该协议的1.1版还对HTTP / 1.0进行了带宽优化改进。例如，HTTP / 1.1引入了分块传输编码，以允许流传输而不是缓冲持久连接上的内容。HTTP流水线进一步减少了延迟时间，允许客户端在等待每个响应之前发送多个请求。协议的另一项附加功能是字节服务，即服务器仅传输客户端明确请求的资源部分。从技术上讲是客户在一个特定的TCP端口（端口号一般为80）上打开一个套接字。如果服务器一直在这个周知的端口上倾听连接，则该连接便会建立起来。然后客户通过该连接发送一个包含请求方法的请求块。HTTP规范定义了9种请求方法，每种请求方法规定了客户和服务器之间不同的信息交换方式，常用的请求方法是GET和POST。服务器将根据客户请求完成相应操作，并以应答块形式返回给客户，最后关闭连接。 报文格式：请求报文、响应报文、请求头各种字段、响应头各种字段 HTTP报文由从客户机到服务器的请求和从服务器到客户机的响应构成。请求报文格式如下： [6] 请求行 － 通用信息头 － 请求头 － 实体头 － 报文主体请求行以方法字段开始，后面分别是 URL 字段和 HTTP 协议版本字段，并以 CRLF 结尾。SP 是分隔符。除了在最后的 CRLF 序列中 CF 和 LF 是必需的之外，其他都可以不要。有关通用信息头，请求头和实体头方面的具体内容可以参照相关文件。应答报文格式如下：状态行 － 通用信息头 － 响应头 － 实体头 － 报文主体状态码元由3位数字组成，表示请求是否被理解或被满足。原因分析是对原文的状态码作简短的描述，状态码用来支持自动操作，而原因分析用来供用户使用。客户机无需用来检查或显示语法。有关通用信息头，响应头和实体头方面的具体内容可以参照相关文件。 HTTP状态码 4.HTTPS协议：详细的握手过程摘要算法、数字签名、数字证书的原理和过程 六、面试常见问题分层的概念问题 1：OSI 有哪几层，会画出来，知道主要几层的各自作用 1. 应用层（数据）：确定进程之间通信的性质以满足用户需要以及提供网络与用户应用2. 表示层（数据）：主要解决拥护信息的语法表示问题，如加密解密3. 会话层（数据）：提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制，如服务器验证用户登录便是由会话层完成的4. 传输层（段）：实现网络不同主机上用户进程之间的数据通信，可靠与不可靠的传输，传输层的错误检测，流量控制等5. 网络层（包）：提供逻辑地址（IP）、选路，数据从源端到目的端的传输6. 数据链路层（帧）：将上层数据封装成帧，用 MAC 地址访问媒介，错误检测与修正7. 物理层（比特流）：设备之间比特流的传输，物理接口，电气特性等问题 2：知道各个层使用的是哪个数据交换设备。（交换机、路由器、网关）1. 网关：应用层、传输层（网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关的结构也和路由器类似，不同的是互连层。网关既可以用于广域网互连，也可以用于局域网互连）2. 路由器：网络层（路由选择、存储转发）3. 交换机：数据链路层、网络层（识别数据包中的 MAC 地址信息，根据 MAC 地址进行转发，并将这些 MAC 地址与对应的端口记录在自己内部的一个地址表中）4. 网桥：数据链路层（将两个 LAN 连起来，根据 MAC 地址来转发帧）5. 集线器（Hub）：物理层（纯硬件设备，主要用来连接计算机等网络端）6. 中继器：物理层（在比特级别对网络信号进行再生和重定时，从而使得它们能够在网络上传输更长的距离） 数据链路层ARP协议问题 1：ARP 的作用？ ARP 为 IP 地址到对应的硬件地址提供动态映射。问题 2：点对点链路使用 ARP 吗？ 不使用问题 3：ARP 高效运行的关键是什么？ 关键是每个主机上都有一个 ARP 的高速缓存。问题 4：ARP 报文的各个字段以及含义？问题 4：ARP 报文的各个字段以及含义？","categories":[],"tags":[]}],"categories":[],"tags":[]}